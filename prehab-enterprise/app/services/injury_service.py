from sqlalchemy.orm import Session
from app.models.injury import InjuryLibrary, InjuryAssignment
from app.schemas.injury import InjuryAssignmentCreate
from datetime import date

import json

def get_injuries_by_body_area(db: Session, body_area: str):
    from sqlalchemy import text
    try:
        # User defined schema: id, body_area, injury_type, immediate_action, recovery_exercises, video_url, red_flags, estimated_recovery_days
        query = text("SELECT * FROM injury_library WHERE body_area = :area")
        results = db.execute(query, {"area": body_area}).all()
        
        items = []
        for row in results:
            item = row._mapping if hasattr(row, '_mapping') else dict(row)
            # Create a dict that matches what frontend expects (and what used to be ORM object)
            # Need to ensure recovery_exercises is list
            try:
                # it might be returned as string from DB or already py dict if driver handles jsonb
                # Postgres pg8000 might return dict for jsonb, sqlite returns str
                # But we handle both
                exercises = item.get("recovery_exercises")
                if isinstance(exercises, str):
                    exercises = json.loads(exercises)
                elif exercises is None:
                    exercises = []
            except:
                exercises = []
            
            # Construct dict
            items.append({
                "id": item.get("id"),
                "body_area": item.get("body_area"),
                "injury_type": item.get("injury_type"),
                "immediate_action": item.get("immediate_action"),
                "recovery_exercises": exercises,
                "video_url": item.get("video_url"),
                "red_flags": item.get("red_flags"),
                "estimated_recovery_days": item.get("estimated_recovery_days")
            })
        return items
    except Exception as e:
        print(f"Error checking library: {e}")
        return []

def get_injury_library_item(db: Session, injury_id: int):
    return db.query(InjuryLibrary).filter(InjuryLibrary.id == injury_id).first()

def get_active_injury(db: Session, player_id: str):
    try:
        from sqlalchemy import text
        # Use raw SQL to bypass ORM mapping issues
        query = text("SELECT * FROM injury_assignments WHERE player_id = :pid AND status = 'Active'")
        result = db.execute(query, {"pid": player_id}).first()
        if result:
            # Result is a Row object, convert to dict-like
            # Note: columns access depends on sqlalchemy version. ._mapping for 1.4+
            row_dict = result._mapping if hasattr(result, '_mapping') else dict(result)
            return row_dict
        return None
    except Exception as e:
        print(f"Error in get_active_injury: {e}")
        return None

def create_injury_assignment(db: Session, assignment: InjuryAssignmentCreate):
    try:
        from sqlalchemy import text
        # User schema: player_id, injury_library_id, status, start_date, progress_percent
        # Using RETURNING * for postgres, or fetch after for sqlite/others
        # Assuming Postgres as user mentioned 'generated by default'
        
        query = text("""
            INSERT INTO injury_assignments (player_id, injury_library_id, start_date, status, progress_percent)
            VALUES (:pid, :lid, :start, 'Active', 0)
        """)
        
        # Determine start date
        start = assignment.start_date or date.today()
        
        db.execute(query, {
            "pid": assignment.player_id,
            "lid": assignment.injury_library_id,
            "start": start
        })
        db.commit()
        
        # Use simple select to return created item (safest cross-db)
        # Assuming last for this player is the one we just made
        fetch_query = text("SELECT * FROM injury_assignments WHERE player_id = :pid AND status = 'Active' ORDER BY id DESC LIMIT 1")
        result = db.execute(fetch_query, {"pid": assignment.player_id}).first()
        
        if result:
            return result._mapping if hasattr(result, '_mapping') else dict(result)
        return None

    except Exception as e:
        print(f"Error in create_injury_assignment: {e}")
        db.rollback()
        return None

def resolve_injury(db: Session, assignment_id: int):
    try:
        from sqlalchemy import text
        # Raw SQL update
        query = text("UPDATE injury_assignments SET status = 'Healed', healed_date = :today WHERE id = :id")
        db.execute(query, {"today": date.today(), "id": assignment_id})
        db.commit()
        
        # Fetch back to return
        select_query = text("SELECT * FROM injury_assignments WHERE id = :id")
        result = db.execute(select_query, {"id": assignment_id}).first()
        if result:
            row_dict = result._mapping if hasattr(result, '_mapping') else dict(result)
            return row_dict
        return None
    except Exception as e:
        print(f"Error in resolve_injury: {e}")
        db.rollback()
        return None

def update_progress(db: Session, assignment_id: int, percent: int):
    try:
        from sqlalchemy import text
        query = text("UPDATE injury_assignments SET progress_percent = :percent WHERE id = :id")
        db.execute(query, {"percent": percent, "id": assignment_id})
        db.commit()
        
        select_query = text("SELECT * FROM injury_assignments WHERE id = :id")
        result = db.execute(select_query, {"id": assignment_id}).first()
        if result:
            row_dict = result._mapping if hasattr(result, '_mapping') else dict(result)
            return row_dict
        return None
    except Exception as e:
        print(f"Error in update_progress: {e}")
        db.rollback()
        return None
